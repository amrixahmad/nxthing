### **Suggestions for Crucial MVP Features**

While your module list is extensive, here are a few high-impact features to consider ensuring a seamless experience, even for an MVP:

1.  **Robust Push Notification System:** The plan mentions notifications for the crew, but a comprehensive system for players is vital. Real-time alerts for match start times, court changes, score updates, and registration confirmations will be a cornerstone of the user experience and reduce confusion on tournament day.
2.  **Persistent Team Management:** For doubles and team events, allow users to create and manage teams from their profile, independent of a specific tournament. This lets players form a team once and easily register for multiple events together, rather than recreating the team for each registration.
3.  **Offline Support for Key Information:** Tournament venues can have unreliable Wi-Fi or cellular service. Caching critical data locally on the device—such as a player's schedule for the day, court assignments, and the current bracket view—ensures the app remains useful even without a stable internet connection.[1]
4.  **Centralized User Profile:** Consolidate all player-centric information into a rich user profile. This should be the hub for their DUPR ID and rating, tournament history, match statistics (win/loss record), payment history, and saved teams.

-----

### **Database Schemas for the MVP**

Here are the foundational database schemas designed for a PostgreSQL backend (as provided by Supabase). These schemas are structured to support all the modules you've outlined, from tournament creation to live scoring and crew management.[2]

**1. Core User and Profile Tables**

```sql
-- Extends Supabase's built-in auth.users table
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  username TEXT UNIQUE,
  avatar_url TEXT,
  dupr_id TEXT,
  dupr_rating NUMERIC(3, 2)
);

CREATE TABLE public.user_wallets (
  user_id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  balance NUMERIC(10, 2) DEFAULT 0.00 NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ
);
```

**2. Tournament Structure Tables**

```sql
CREATE TYPE tournament_status AS ENUM ('draft', 'registration_open', 'upcoming', 'active', 'completed', 'cancelled');
CREATE TYPE participation_type AS ENUM ('singles', 'doubles', 'team');
CREATE TYPE tournament_format AS ENUM ('single_elimination', 'double_elimination', 'round_robin');

CREATE TABLE public.tournaments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  organizer_id UUID NOT NULL REFERENCES public.profiles(id),
  title TEXT NOT NULL,
  description TEXT,
  banner_url TEXT,
  venue_name TEXT,
  start_date TIMESTAMPTZ NOT NULL,
  end_date TIMESTAMPTZ,
  registration_start_date TIMESTAMPTZ NOT NULL,
  registration_end_date TIMESTAMPTZ NOT NULL,
  status tournament_status DEFAULT 'draft' NOT NULL,
  terms_and_conditions TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE public.tournament_categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tournament_id BIGINT NOT NULL REFERENCES public.tournaments(id) ON DELETE CASCADE,
  name TEXT NOT NULL, -- e.g., "Men's Doubles 4.0+"
  participation_type participation_type NOT NULL,
  min_age INT,
  max_age INT,
  gender_restriction TEXT, -- e.g., 'male', 'female', 'mixed'
  min_skill_level NUMERIC(3, 2),
  max_skill_level NUMERIC(3, 2),
  max_teams INT,
  members_per_team_min INT DEFAULT 1,
  members_per_team_max INT DEFAULT 1,
  registration_fee NUMERIC(10, 2) NOT NULL
);
```

**3. Registration and Team Tables**

```sql
CREATE TABLE public.teams (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL,
  captain_id UUID NOT NULL REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE public.team_members (
  team_id BIGINT NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  PRIMARY KEY (team_id, user_id)
);

CREATE TABLE public.registrations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category_id BIGINT NOT NULL REFERENCES public.tournament_categories(id) ON DELETE CASCADE,
  user_id UUID REFERENCES public.profiles(id), -- For singles
  team_id BIGINT REFERENCES public.teams(id), -- For doubles/teams
  registered_at TIMESTAMPTZ DEFAULT NOW(),
  check_in_time TIMESTAMPTZ,
  banned_paddle_acknowledged BOOLEAN DEFAULT FALSE,
  qr_code_identifier TEXT UNIQUE NOT NULL
);
```

**4. Match, Scoring, and Crew Tables**

```sql
CREATE TYPE crew_role AS ENUM ('host', 'referee', 'operations', 'point_guard');
CREATE TYPE match_status AS ENUM ('pending', 'active', 'completed', 'paused', 'walkover', 'disqualified');

CREATE TABLE public.tournament_crew (
  tournament_id BIGINT NOT NULL REFERENCES public.tournaments(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  role crew_role NOT NULL,
  PRIMARY KEY (tournament_id, user_id)
);

CREATE TABLE public.courts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tournament_id BIGINT NOT NULL REFERENCES public.tournaments(id) ON DELETE CASCADE,
  name TEXT NOT NULL -- e.g., "Court 1", "Championship Court"
);

CREATE TABLE public.matches (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category_id BIGINT NOT NULL REFERENCES public.tournament_categories(id) ON DELETE CASCADE,
  court_id BIGINT REFERENCES public.courts(id),
  referee_id UUID REFERENCES public.profiles(id),
  round_number INT NOT NULL,
  match_number INT NOT NULL,
  team1_id BIGINT REFERENCES public.teams(id),
  team2_id BIGINT REFERENCES public.teams(id),
  winner_id BIGINT REFERENCES public.teams(id),
  team1_score INT,
  team2_score INT,
  status match_status DEFAULT 'pending' NOT NULL,
  scheduled_start_time TIMESTAMPTZ,
  actual_start_time TIMESTAMPTZ,
  end_time TIMESTAMPTZ,
  next_match_id BIGINT REFERENCES public.matches(id), -- For bracket progression
  team1_signature TEXT, -- Store digital signature data
  team2_signature TEXT
);
```

**5. Financial and Logging Tables**

```sql
CREATE TABLE public.payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  registration_id BIGINT NOT NULL REFERENCES public.registrations(id),
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  amount NUMERIC(10, 2) NOT NULL,
  status TEXT NOT NULL, -- e.g., 'succeeded', 'failed'
  gateway_transaction_id TEXT,
  invoice_url TEXT,
  receipt_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE public.audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  admin_id UUID NOT NULL REFERENCES public.profiles(id),
  action TEXT NOT NULL, -- e.g., 'overwrite_match_result'
  target_entity TEXT, -- e.g., 'matches'
  target_id BIGINT,
  change_details JSONB, -- Store what was changed
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

-----

### **MVP Development Plan**

This plan is broken into four incremental phases, prioritizing the core functionality required to run a tournament from start to finish.

**Phase 1: Foundation, Authentication & Tournament Creation (Host Flow)**

  * **Goal:** Establish the project architecture and enable tournament hosts to create and define their events.
  * **Tasks:**
    1.  **Project Setup:** Initialize the project using the `aaronksaunders/expo-supabase-ai-template`, configure Supabase, and clean out non-essential template code.[3]
    2.  **Schema Implementation:** Create and apply the SQL migrations for the core tables: `profiles`, `tournaments`, and `tournament_categories`.
    3.  **Authentication:** Customize the template's authentication screens to include fields for `dupr_id` and `dupr_rating` during sign-up.
    4.  **Create Tournament Module:** Build the multi-step form for hosts to create a tournament. This includes filling in details, defining categories (with restrictions on age, gender, level), setting fees, and specifying the tournament format as outlined in your document.[2]
    5.  **Host Dashboard:** Create a screen where hosts can view and manage the tournaments they have created.

**Phase 2: Player Registration & Payment Flow**

  * **Goal:** Allow players to find, view details of, and register for tournaments.
  * **Tasks:**
    1.  **Tournament Listing:** Develop the main screen for players to browse and search for all tournaments with a status of `registration_open` or `upcoming`.[2]
    2.  **Tournament Details Screen:** Build the view that displays all public information about a tournament, including its categories, rules, format, and a list of registered players.
    3.  **Registration Module:** Implement the player registration flow.
          * System validates player eligibility against category rules (age, gender, skill level).[2]
          * For doubles/team events, allow a captain to create a team and invite members via email or user code.
          * Implement the "banned paddle" acknowledgment checkbox.
    4.  **Payment Gateway Integration:** Integrate a payment provider to handle registration fees. On successful payment, create records in the `payments` and `registrations` tables and generate a unique QR code identifier.

**Phase 3: Automated Matching & Bracket Visualization**

  * **Goal:** Automatically generate matches and display interactive brackets to all users.
  * **Tasks:**
    1.  **Auto Matching Edge Function:** Create a Supabase Edge Function that triggers when a host starts the tournament. This function will:
          * Fetch all registered participants for each category.
          * Seed players/teams based on skill level.
          * Generate all `matches` records for the chosen format (e.g., single elimination), linking them with `next_match_id` to form the bracket structure.[2]
          * Perform initial auto-court assignments if courts are defined.
    2.  **Bracket Visualization:** Integrate a library like `@g-loot/react-tournament-brackets` into the Tournament Details screen to fetch and render the generated match data in a clear, interactive bracket format.[4]
    3.  **Manual Override (Host):** In the Host Dashboard, provide an interface for hosts to perform manual adjustments to pairings and court assignments, with changes logged to the `audit_logs` table.[2]

**Phase 4: Crew App, Live Scoring & Real-Time Updates**

  * **Goal:** Empower the tournament crew to manage on-site operations, primarily live scoring, and reflect updates in real-time on the player app.
  * **Tasks:**
    1.  **Crew App Foundation:** Build a separate, streamlined mobile app for the tournament crew with a dedicated login (no sign-up).[2]
    2.  **Crew Invitation & Roles:** Implement the flow for hosts to invite crew members and assign roles (`referee`, `operations`, etc.). Crew members can view their assigned tournaments and roles.
    3.  **Check-In Module:** Implement the QR code scanner in the Crew App for the Operations role to check in players and spectators.
    4.  **Referee Module & Live Scoring:** This is the core of the Crew App.
          * Referees see a list of their assigned matches and courts.
          * Build the point-by-point live scoring interface, including marking the serving side, recording penalties, and handling side switches.[2]
          * Implement the digital signature capture for both parties to confirm the final score.
    5.  **Real-Time Integration:** Use Supabase Realtime Subscriptions to listen for changes in the `matches` table. When a referee submits a final score, the player app's bracket view should update automatically to show the result and advance the winner.