-- Enums
create type entry_status as enum ('pending','accepted','waitlisted','withdrawn','rejected');
create type payment_status as enum ('unpaid','paid','refunded','waived');
create type bracket_type as enum ('single_elimination');
create type bracket_status as enum ('draft','active','completed','archived');
create type match_status as enum ('pending','scheduled','in_progress','completed','bye','walkover','cancelled');

-- Entries: one per team/singles registration in a category
create table if not exists public.entries (
  id bigint generated by default as identity primary key,
  category_id bigint not null references public.tournament_categories(id) on delete cascade,
  created_by uuid not null references public.profiles(id),
  team_name text,
  seed int,
  rating numeric(4,2),
  status entry_status not null default 'pending',
  payment_status payment_status not null default 'unpaid',
  payment_amount numeric(10,2),
  payment_currency text default 'usd',
  payment_reference text,
  paid_at timestamptz,
  created_at timestamptz default now()
);

-- Unique seed per category when present
create unique index if not exists entries_category_seed_unique on public.entries(category_id, seed) where seed is not null;
create index if not exists entries_category_idx on public.entries(category_id);
create index if not exists entries_created_by_idx on public.entries(created_by);

-- Entry members: link players to an entry (1 for singles, 2+ for doubles/teams)
create table if not exists public.entry_members (
  entry_id bigint not null references public.entries(id) on delete cascade,
  profile_id uuid not null references public.profiles(id),
  created_at timestamptz default now(),
  primary key (entry_id, profile_id)
);
create index if not exists entry_members_profile_idx on public.entry_members(profile_id);

-- Brackets: one active bracket per category in MVP
create table if not exists public.brackets (
  id bigint generated by default as identity primary key,
  category_id bigint not null references public.tournament_categories(id) on delete cascade,
  type bracket_type not null default 'single_elimination',
  status bracket_status not null default 'active',
  created_at timestamptz default now(),
  unique (category_id)
);
create index if not exists brackets_category_idx on public.brackets(category_id);

-- Matches for a bracket
create table if not exists public.matches (
  id bigint generated by default as identity primary key,
  bracket_id bigint not null references public.brackets(id) on delete cascade,
  round_number int not null,
  match_number int not null,
  participant1_entry_id bigint references public.entries(id),
  participant2_entry_id bigint references public.entries(id),
  winner_entry_id bigint references public.entries(id),
  next_match_id bigint references public.matches(id),
  next_match_slot smallint check (next_match_slot in (1,2)),
  status match_status not null default 'pending',
  scheduled_at timestamptz,
  court text,
  score text,
  created_at timestamptz default now(),
  unique (bracket_id, round_number, match_number)
);
create index if not exists matches_bracket_idx on public.matches(bracket_id);
create index if not exists matches_bracket_round_idx on public.matches(bracket_id, round_number);
create index if not exists matches_next_match_idx on public.matches(next_match_id);

-- RLS
alter table public.entries enable row level security;
alter table public.entry_members enable row level security;
alter table public.brackets enable row level security;
alter table public.matches enable row level security;

-- Public read access
drop policy if exists "Entries readable by everyone" on public.entries;
create policy "Entries readable by everyone" on public.entries for select using (true);

drop policy if exists "Entry members readable by everyone" on public.entry_members;
create policy "Entry members readable by everyone" on public.entry_members for select using (true);

drop policy if exists "Brackets readable by everyone" on public.brackets;
create policy "Brackets readable by everyone" on public.brackets for select using (true);

drop policy if exists "Matches readable by everyone" on public.matches;
create policy "Matches readable by everyone" on public.matches for select using (true);

-- Entries: players can insert during registration window for categories in open tournaments
-- Organizer can insert too
drop policy if exists "Players can insert own entries during registration" on public.entries;
create policy "Players can insert own entries during registration" on public.entries
  for insert with check (
    auth.uid() = created_by and exists (
      select 1
      from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id
        and t.status = 'registration_open'
        and now() between t.registration_start_date and t.registration_end_date
    )
  );

drop policy if exists "Organizer can insert entries" on public.entries;
create policy "Organizer can insert entries" on public.entries
  for insert with check (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  );

-- Entries: participants can update only their own and only to safe statuses; organizer can update
drop policy if exists "Players can update own entries (safe)" on public.entries;
create policy "Players can update own entries (safe)" on public.entries
  for update using (created_by = auth.uid())
  with check (
    created_by = auth.uid() and status in ('pending','withdrawn')
  );

drop policy if exists "Organizer can update entries" on public.entries;
create policy "Organizer can update entries" on public.entries
  for update using (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  );

-- Entries delete: players can delete own; organizer can delete
drop policy if exists "Players can delete own entries" on public.entries;
create policy "Players can delete own entries" on public.entries
  for delete using (created_by = auth.uid());

drop policy if exists "Organizer can delete entries" on public.entries;
create policy "Organizer can delete entries" on public.entries
  for delete using (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  );

-- Entry members: creator or organizer manages members
drop policy if exists "Players manage own entry members" on public.entry_members;
create policy "Players manage own entry members" on public.entry_members
  for all using (
    exists (
      select 1 from public.entries e where e.id = entry_id and e.created_by = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.entries e where e.id = entry_id and e.created_by = auth.uid()
    )
  );

drop policy if exists "Organizer manages entry members" on public.entry_members;
create policy "Organizer manages entry members" on public.entry_members
  for all using (
    exists (
      select 1
      from public.entries e
      join public.tournament_categories tc on tc.id = e.category_id
      join public.tournaments t on t.id = tc.tournament_id
      where e.id = entry_id and t.organizer_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1
      from public.entries e
      join public.tournament_categories tc on tc.id = e.category_id
      join public.tournaments t on t.id = tc.tournament_id
      where e.id = entry_id and t.organizer_id = auth.uid()
    )
  );

-- Brackets and Matches: organizer-only writes
drop policy if exists "Organizer can write brackets" on public.brackets;
create policy "Organizer can write brackets" on public.brackets
  for all using (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.tournament_categories tc
      join public.tournaments t on t.id = tc.tournament_id
      where tc.id = category_id and t.organizer_id = auth.uid()
    )
  );

drop policy if exists "Organizer can write matches" on public.matches;
create policy "Organizer can write matches" on public.matches
  for all using (
    exists (
      select 1 from public.brackets b
      join public.tournament_categories tc on tc.id = b.category_id
      join public.tournaments t on t.id = tc.tournament_id
      where b.id = bracket_id and t.organizer_id = auth.uid()
    )
  )
  with check (
    exists (
      select 1 from public.brackets b
      join public.tournament_categories tc on tc.id = b.category_id
      join public.tournaments t on t.id = tc.tournament_id
      where b.id = bracket_id and t.organizer_id = auth.uid()
    )
  );
